h2. Requirements

* "Ruby 1.8":http://www.ruby-lang.org/
* "Ruby Gems":http://www.rubygems.org/
** "ParseTree":http://github.com/seattlerb/parsetree/
** "rake":http://rake.rubyforge.org/ <sup><a href="#fn1">1</a></sup>
** "rcov":http://eigenclass.org/hiki/rcov/ <sup><a href="#fn1">1</a></sup>
** "rspec":http://www.rspec.info/ <sup><a href="#fn1">1</a></sup>
** "ruby2ruby":http://github.com/seattlerb/ruby2ruby/

fn1. are only necessary for executing the @rakefile@ which runs the unit tests and generates test and code coverage reports. Otherwise, the basic requirements are enough.

h2. File Structure

Each item at level 1 in the following list represents a component of the framework. Each item at level 2 indicates a source file containing part of the implementation of the corresponding component. Those files are stored in the @src/@ directory (see *Git Repository* for more information).

All components, except the Libraries, have a façade file in case they consist on several files. Just importing (@require@) the façade is sufficient for accessing all the logic implemented by the component. Façades are labelled <sup>f</sup>.

When the façade is merely a list of imports and does not contain any real code, it is labelled <sup>h</sup>, after header files.

Since the code is thoroughly unit tested, most classes have their RSpec counterpart in the @spec/@ directory. When this is the case, files are labelled <sup>s</sup>.

* Property: property abstraction
** @property@ <sup>f,h</sup>
** @property_class@ <sup>s</sup>: _Property_ class definition (property namespace)
** @property_core@ <sup>s</sup>: _Property_ instances definition
** @property_ast@: AST for representing a simplified view of predicates
** @property_rcollector@ <sup>s</sup>: _ResultCollector_ stores subexpression results of instrumented predicates
** @property_pvisitor@ <sup>s</sup>: _PropertyVisitor_ instruments _Properties_ and builds a simplied AST
** @property_covervisitor@ <sup>s</sup>: _CoverVisitor_ computes property coverage goals
** @property_covertable@ <sup>s</sup>: _CoverTable_ stores property coverage
** @property_language@ <sup>s</sup>: DSL for defining properties
** @property_cases@ <sup>s</sup>


* Contract
** @contract@ <sup>f,h</sup>
** @contract_core@ <sup>s</sup>
** @contract_language@ <sup>s</sup>


* Pipeline: pipeline abstraction, after the Pipes & Filters architectural pattern
** @pipeline@ <sup>f,s</sup>: pipeline interfaces and partial implementations
** @plist@ <sup>s</sup>: _PList_, Wrapper of _Array_, the data to flow along the pipeline
** @action@ <sup>s</sup>: utility filters for placing arbitrary code on the pipeline


* Runner
** @runner@ <sup>f,p</sup>


* Simplerunner
* @simplerunner@ <sup>f,s</sup>


* Complexrunner
* @complexrunner@ <sup>f,s</sup>


* Strategy
** @strategy@ <sup>f,p</sup>


* Human
** @cases@ <sup>s</sup>

* Random
** @random@ <sup>f,h</sup>
** @random_combinators@ <sup>s</sup>
** @random_string@ <sup>s</sup>
** @random_strategy@ <sup>s</sup>


* Exhaustive
** @exhaustive@ <sup>f,h</sup>
** @exhaustive_combinators@ <sup>s</sup>
** @exhaustive_lazy@ <sup>s</sup>
** @exhaustive_string@ <sup>s</sup>
** @exhaustive_strategy@ <sup>s</sup>


* Historic
** @historic@ <sup>f,s</sup>
** @errordatabase@ <sup>s</sup>


* UI
** @ui@ <sup>s</sup>
** @ui_protocol@


* BatchUI
** @batchui@


* TextUI
** @textui@


* Libraries
** @decorator@ <sup>s</sup>: Decorator design pattern
** @initializer@ <sup>s</sup>: simplified constructors through metaprogramming, à la CLOS
** @lineutils@ <sup>s</sup>: line manipulation functions to adapt to screen size
** @permutations@ <sup>s</sup>: Lisp-like macro for generating permutations
** @progressbar@ <sup>s</sup>: text-mode progress bar UI component
** @scrollpane@: text-mode interactive scroll pane UI component
** @visitable@ <sup>s</sup>: Visitor design pattern